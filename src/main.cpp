#include <Arduino.h> #include <SPI.h> #include <TFT_eSPI.h> #include "defaultEye.h" // Must contain sclera[][], iris[][], upper[][], lower[][] // --- PIN CONFIGURATION --- #define CS_LEFT 15 #define CS_RIGHT 2 // --- DISPLAY SETTINGS --- #define SCREEN_WIDTH 128 #define SCREEN_HEIGHT 160 #define EYE_SIZE 128 #define EYE_RADIUS 58.0f #define IRIS_RADIUS_SQ (30 * 30) TFT_eSPI tft = TFT_eSPI(); static uint16_t lineBuf[EYE_SIZE]; typedef struct { int8_t csPin; float xAngle; // Horizontal gaze (radians) float yAngle; // Vertical gaze (radians) int16_t blink; // 0..255 int16_t blinkDest; uint32_t lastBlinkTime; } EyeState; EyeState leftEye = { CS_LEFT, 0, 0, 0, 0, 0 }; EyeState rightEye = { CS_RIGHT, 0, 0, 0, 0, 0 }; void updatePhysics(EyeState &eye); void drawEye(EyeState &eye); void setup() { Serial.begin(115200); pinMode(CS_LEFT, OUTPUT); pinMode(CS_RIGHT, OUTPUT); digitalWrite(CS_LEFT, HIGH); digitalWrite(CS_RIGHT, HIGH); digitalWrite(CS_LEFT, LOW); digitalWrite(CS_RIGHT, LOW); tft.init(); tft.setRotation(0); tft.fillScreen(TFT_BLACK); digitalWrite(CS_LEFT, HIGH); digitalWrite(CS_RIGHT, HIGH); } void loop() { static uint32_t nextMove = 0; static float destX = 0, destY = 0; uint32_t t = millis(); // Random Saccades if (t > nextMove) { destX = random(-45, 46) / 100.0f; // -0.45 to 0.45 radians destY = random(-35, 36) / 100.0f; nextMove = t + random(400, 2200); } // Smooth Interpolation leftEye.xAngle = leftEye.xAngle * 0.85f + destX * 0.15f; leftEye.yAngle = leftEye.yAngle * 0.85f + destY * 0.15f; rightEye.xAngle = leftEye.xAngle; rightEye.yAngle = leftEye.yAngle; updatePhysics(leftEye); rightEye.blink = leftEye.blink; digitalWrite(CS_LEFT, LOW); drawEye(leftEye); digitalWrite(CS_LEFT, HIGH); digitalWrite(CS_RIGHT, LOW); drawEye(rightEye); digitalWrite(CS_RIGHT, HIGH); } void updatePhysics(EyeState &eye) { uint32_t t = millis(); if (eye.blink != eye.blinkDest) { if (eye.blink < eye.blinkDest) eye.blink = min(eye.blink + 22, (int)eye.blinkDest); else eye.blink = max(eye.blink - 12, (int)eye.blinkDest); } else { if (t > eye.lastBlinkTime) { eye.blinkDest = 255; eye.lastBlinkTime = t + random(1500, 5000); } else if (eye.blinkDest == 255) { eye.blinkDest = 0; } } } void drawEye(EyeState &eye) { const int yOffset = (SCREEN_HEIGHT - EYE_SIZE) / 2; const int center = EYE_SIZE / 2; // Precompute rotation values float cosX = cos(eye.xAngle), sinX = sin(eye.xAngle); float cosY = cos(eye.yAngle), sinY = sin(eye.yAngle); tft.startWrite(); tft.setAddrWindow(0, yOffset, EYE_SIZE, EYE_SIZE); for (int y = 0; y < EYE_SIZE; y++) { uint8_t lidThresh = (uint8_t)eye.blink; float py = (float)(y - center) / EYE_RADIUS; for (int x = 0; x < EYE_SIZE; x++) { // 1. Eyelid check if (upper[y][x] > (255 - lidThresh) || lower[y][x] > (255 - lidThresh)) { lineBuf[x] = 0x0000; continue; } // 2. Project to 3D sphere (Z-depth from sphere equation) float px = (float)(x - center) / EYE_RADIUS; float pz2 = 1.0f - px*px - py*py; if (pz2 < 0.0f) { lineBuf[x] = 0x0000; continue; } float pz = sqrtf(pz2); // 3. Apply 3D rotation (inverse gaze transform) float y2 = py * cosY - pz * sinY; float z2 = py * sinY + pz * cosY; float x3 = px * cosX - z2 * sinX; // 4. Map back to texture coordinates int u = center + (int)(x3 * EYE_RADIUS); int v = center + (int)(y2 * EYE_RADIUS); if (u < 0) u = 0; else if (u >= EYE_SIZE) u = EYE_SIZE - 1; if (v < 0) v = 0; else if (v >= EYE_SIZE) v = EYE_SIZE - 1; // 5. Select iris or sclera texture int du = u - center; int dv = v - center; lineBuf[x] = ((du*du + dv*dv) < IRIS_RADIUS_SQ) ? iris[v][u] : sclera[v][u]; } tft.pushColors(lineBuf, EYE_SIZE, false); } tft.endWrite(); }